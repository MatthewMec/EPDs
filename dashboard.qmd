```{python}
#Import Libraries

import polars as pl
import pandas as pd
import streamlit as st
import numpy as np
import xlsx2csv
from lets_plot import *
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, accuracy_score
```


```{python}
epds = pl.read_csv('2025Bull.csv', ignore_errors=True).with_row_index().drop(['Sex', 'DOB','BrdCds'])

epds = epds.with_columns(mean = pl.sum_horizontal(['HB','GM']) / 2)


epds = (epds.with_columns([
    pl.col("AnimalID").str.split_exact(" - ", 1).
    alias("split_column")]).
    with_columns(pl.col('split_column')).
    unnest('split_column').
    rename({'field_0' : 'cow', 'field_1' : 'bull'})
)

criteria = {
    "ME": -1,
    "CED": 12,
    "Milk": 26,
    "CEM": 7,
    "Marb": 0.4,
    "STAY": 17
}

epds_mins = epds.filter(
    (pl.col("ME") <= criteria["ME"]) &
    (pl.col("CED") >= criteria["CED"]) &
    (pl.col("Milk") >= criteria["Milk"]) &
    (pl.col("CEM") >= criteria["CEM"]) &
    (pl.col("Marb") >= criteria["Marb"]) &
    (pl.col("STAY") >= criteria["STAY"])
)

mean_hb = epds.select(pl.mean('HB'))
mean_milk = epds.select(pl.mean('STAY'))
mean_gm = epds.select(pl.mean('GM'))

max_gm_epds = epds.group_by("cow").agg([
    pl.col("GM").max().alias("GM")
]).join(epds, on=["cow", "GM"])

max_hg_epds = epds.group_by("cow").agg([
    pl.col("HB").max().alias("HB")
]).join(epds, on=["cow", "HB"])
```

6 cows who cannot meet milk requirement at all:C29, D10, G07, H15, H11, H59 

4 cows cannot meet marb requirements at all: C44, F83, F03, C32

17 other cows that cannot meet the requirements in conjuction

```{python}

#epds.select(pl.col('cow').n_unique()).item()
epds_mins.select(pl.col('cow').n_unique()).item()

```

```{python}
cows = epds.select(pl.col('cow').unique()).to_series().to_list()

cows_meeting_requirements = epds_mins.select(pl.col('cow').unique()).to_series().to_list()

# Compare the lists
cows_in_both = set(cows).intersection(cows_meeting_requirements)

cows_only_in_original = set(cows) - set(cows_meeting_requirements)

```

```{python}

cows_failing = (epds.filter(pl.col("cow").is_in(cows_only_in_original)))

max_hg = cows_failing.group_by("cow").agg([
    pl.col("HB").max().alias("HB")
]).join(cows_failing, on=["cow", "HB"])

max_gm = cows_failing.group_by("cow").agg([
    pl.col("GM").max().alias("GM")
]).join(cows_failing, on=["cow", "GM"])

```

```{python}
max_rea_by_cow = epds_mins.group_by("cow").agg(
    [pl.all().first(), pl.col("REA").max().alias("max_REA")]
)


max_cw_by_cow = epds_mins.group_by("cow").agg(
    [pl.all().first(), pl.col("CW").max().alias("max_cw")]
)

min_yg_by_cow = epds_mins.group_by("cow").agg(
    [pl.all().first(), pl.col("YG").min().alias("min_yg")]
)

```



```{python}
mean_by_cow = epds.group_by("cow").agg([
    pl.col("HB").mean().alias("mean_hb"),
    pl.col("GM").mean().alias("mean_gm")
])

comparison = mean_by_cow.with_columns([
    pl.when((pl.col("mean_hb") > mean_hb) & (pl.col("mean_gm") > mean_gm))
      .then(pl.lit("both"))
      .when(pl.col("mean_hb") > mean_hb)
      .then(pl.lit("HB"))
      .when(pl.col("mean_gm") > mean_gm)
      .then(pl.lit("GM"))
      .otherwise(pl.lit("none"))
      .alias("comparison_result")
])

mean_by_bull = epds.group_by("bull").agg([
    pl.col("HB").mean().alias("mean_hb"),
    pl.col("GM").mean().alias("mean_gm")
])

comparison_bull = mean_by_bull.with_columns([
    pl.when((pl.col("mean_hb") > mean_hb) & (pl.col("mean_gm") > mean_gm))
      .then(pl.lit("both"))
      .when(pl.col("mean_hb") > mean_hb)
      .then(pl.lit("HB"))
      .when(pl.col("mean_gm") > mean_gm)
      .then(pl.lit("GM"))
      .otherwise(pl.lit("none"))
      .alias("comparison_result")
])
```

```{python}
mean_by_failing_cow = cows_failing.group_by("cow").agg([
    pl.col("HB").mean().alias("mean_hb"),
    pl.col("GM").mean().alias("mean_gm")
])

comparison_failing = mean_by_failing_cow.with_columns([
    pl.when((pl.col("mean_hb") > mean_hb) & (pl.col("mean_gm") > mean_gm))
      .then(pl.lit("both"))
      .when(pl.col("mean_hb") > mean_hb)
      .then(pl.lit("HB"))
      .when(pl.col("mean_gm") > mean_gm)
      .then(pl.lit("GM"))
      .otherwise(pl.lit("none"))
      .alias("comparison_result")
])


```


```{python}
epds_with_target = epds.with_columns(((pl.col('HB') + pl.col('GM')) / 2).alias('target'))

```


```{python}

# Calculate the mean of the 'target' column
mean_target = epds_with_target.select(pl.mean('target')).item()

# Add the new column 'comparison' based on the mean of the 'target' column
epds_with_target = epds_with_target.with_columns(
    pl.when(pl.col('target') > mean_target)
    .then(pl.lit("above"))
    .otherwise(pl.lit("below"))
    .alias('comparison')
)

# Calculate the mean of the 'target' column
mean_hb = epds_with_target.select(pl.mean('HB')).item()

# Add the new column 'comparison' based on the mean of the 'target' column
epds_with_target = epds_with_target.with_columns(
    pl.when(pl.col('HB') > mean_hb)
    .then(pl.lit("above"))
    .otherwise(pl.lit("below"))
    .alias('comparison_hb')
)

# Calculate the mean of the 'target' column
mean_gm = epds_with_target.select(pl.mean('GM')).item()

# Add the new column 'comparison' based on the mean of the 'target' column
epds_with_target = epds_with_target.with_columns(
    pl.when(pl.col('GM') > mean_gm)
    .then(pl.lit("above"))
    .otherwise(pl.lit("below"))
    .alias('comparison_gm')
)
df = epds
```


```{python}
#Model Creation

def judge(row):
    if row['comparison'] == 'above':
        return row['target']
    elif row['comparison_hb'] == 'above':
        return row['HB']
    elif row['comparison_gm'] == 'above':
        return row['GM']
    else:
        return max(row['target'], row['HB'], row['GM'])

```

```{python}
# Define maximum number of bulls for breeding 

bull_limit = len(df['cow'].unique()) // 5

prob = LpProblem("Breeding_Optimization", LpMaximize)

vars = pl.DataFrame({
    'cow': df['cow'],
    'bull': df['bull'],
    'Variable': [LpVariable(f"x_{i}_{j}", cat=LpBinary) for i in range(len(df)) for j in range(len(df['bull'].unique()))]
})
```

```{python}
from pulp import LpProblem, LpVariable, LpMaximize, lpSum, LpBinary

# Define constraints
bull_limit = len(epds_with_target['cow'].unique()) // 5

# Initialize the problem
prob = LpProblem("Breeding_Optimization", LpMaximize)

# Create decision variables
n = len(epds_with_target)
bulls = epds_with_target['bull'].unique()
vars = {
    (i, j): LpVariable(f"x_{i}_{j}", cat=LpBinary)
    for i in range(n)
    for j in range(len(bulls))
}

# Objective function: Maximize total target based on 'above' or 'below'
prob += lpSum(
    vars[i, j] * epds_with_target['target'][i]
    for i in range(n)
    for j in range(len(bulls))
    if epds_with_target['comparison'][i] == 'above'
)

# Add constraints: Each bull can breed with at most 1/5 of the cows
for bull in bulls:
    prob += lpSum(
        vars[i, j]
        for i in range(n)
        if epds_with_target['bull'][i] == bull
        for j in range(len(bulls))
    ) <= bull_limit

# Constraints: Each cow breeds only once
for cow in epds_with_target['cow'].unique():
    prob += lpSum(
        vars[i, j]
        for i in range(n)
        if epds_with_target['cow'][i] == cow
        for j in range(len(bulls))
    ) == 1

# Solve the problem
prob.solve()

# Extract the results
result = []
for i in range(n):
    for j in range(len(bulls)):
        if vars[i, j].varValue == 1:
            result.append((epds_with_target['cow'][i], epds_with_target['bull'][j]))

result = pl.DataFrame(result)

```

```{python}
result = result.transpose()
result = result.rename({
    result.columns[0]: "cow",
    result.columns[1]: "bull"
})

```

```{python}
result.write_csv("result.csv", separator= ",")
```

```{python}
bull_counts = result.group_by("bull").agg(
    pl.len().alias("count")
).sort("count", descending=True)

bull_counts
```

```{python}
#pulp options
@st.cache_data
def run_optimization(_epds_with_target):
    try:
        # Get unique cows and bulls
        cows = _epds_with_target['cow'].unique().to_list()
        bulls = _epds_with_target['bull'].unique().to_list()
        
        # Calculate the bull limit (1/5 of the unique cows)
        bull_limit = len(cows) // 5
        
        # Calculate means for relevant metrics
        mean_values = {
            'HB': _epds_with_target.select(pl.mean('HB')).item(),
            'GM': _epds_with_target.select(pl.mean('GM')).item(),
            'target': _epds_with_target.select(pl.mean('target')).item(),
            'ME': _epds_with_target.select(pl.mean('ME')).item(),
            'CED': _epds_with_target.select(pl.mean('CED')).item(),
            'Milk': _epds_with_target.select(pl.mean('Milk')).item(),
            'CEM': _epds_with_target.select(pl.mean('CEM')).item(),
            'Marb': _epds_with_target.select(pl.mean('Marb')).item(),
            'STAY': _epds_with_target.select(pl.mean('STAY')).item()
        }
        
        # Prepare data for optimization
        pairing_data = []
        for i in range(len(_epds_with_target)):
            row = _epds_with_target.row(i)
            cow = row[_epds_with_target.columns.index('cow')]
            bull = row[_epds_with_target.columns.index('bull')]
            
            # Count metrics where this pairing exceeds the mean
            above_mean_count = 0
            for metric in ['HB', 'GM', 'target', 'CED', 'Milk', 'CEM', 'Marb', 'STAY']:
                metric_idx = _epds_with_target.columns.index(metric)
                metric_value = row[metric_idx]
                
                # For ME, lower is better so we check if it's below mean
                if metric == 'ME':
                    if row[_epds_with_target.columns.index('ME')] < mean_values['ME']:
                        above_mean_count += 1
                # For others, higher is better
                elif metric_value > mean_values[metric]:
                    above_mean_count += 1
            
            pairing_data.append({
                'index': i,
                'cow': cow,
                'bull': bull,
                'above_mean_count': above_mean_count
            })
        
        # Initialize the optimization problem
        prob = LpProblem("Breeding_Optimization", LpMaximize)
        
        # Create decision variables (binary variables for each pairing)
        vars = {
            i: LpVariable(f"x_{i}", cat=LpBinary)
            for i in range(len(pairing_data))
        }
        
        # Objective function: Maximize the number of metrics above mean across all selected pairings
        prob += lpSum(
            vars[i] * pairing_data[i]['above_mean_count']
            for i in range(len(pairing_data))
        )
        
        # Constraint: Each cow breeds only once
        for cow in cows:
            prob += lpSum(
                vars[i]
                for i in range(len(pairing_data))
                if pairing_data[i]['cow'] == cow
            ) <= 1
        
        # Constraint: Each bull can breed with at most bull_limit cows
        for bull in bulls:
            prob += lpSum(
                vars[i]
                for i in range(len(pairing_data))
                if pairing_data[i]['bull'] == bull
            ) <= bull_limit
        
        # Solve the problem
        prob.solve()
        
        # Extract the results
        result = []
        for i in range(len(pairing_data)):
            if vars[i].value() == 1:  # If this pairing is selected
                result.append({
                    "cow": pairing_data[i]['cow'],
                    "bull": pairing_data[i]['bull'],
                    "above_mean_metrics": pairing_data[i]['above_mean_count']
                })
        
        if not result:
            return None
            
        result_df = pl.DataFrame(result)
        
        # Count bulls
        bull_counts = result_df.group_by("bull").agg(
            pl.len().alias("count")
        ).sort("count", descending=True)
        
        return {
            "pairings": result_df,
            "bull_counts": bull_counts
        }
    except Exception as e:
        st.error(f"Optimization error: {e}")
        return None



# Option 2

@st.cache_data
def run_optimization(_epds_with_target):
    try:
        # Define constraints
        bull_limit = len(_epds_with_target['cow'].unique()) // 5

        # Initialize the problem
        prob = LpProblem("Breeding_Optimization", LpMaximize)

        # Create decision variables
        n = len(_epds_with_target)
        bulls = _epds_with_target['bull'].unique().to_list()
        vars = {
            (i, j): LpVariable(f"x_{i}_{j}", cat=LpBinary)
            for i in range(n)
            for j in range(len(bulls))
        }

        # Objective function: Maximize total target based on 'above' or 'below'
        prob += lpSum(
            vars[i, j] * _epds_with_target['target'][i]
            for i in range(n)
            for j in range(len(bulls))
            if _epds_with_target['comparison'][i] == 'above'
        )

        # Add constraints: Each bull can breed with at most 1/5 of the cows
        for bull_idx, bull in enumerate(bulls):
            prob += lpSum(
                vars[i, bull_idx]
                for i in range(n)
                if _epds_with_target['bull'][i] == bull
            ) <= bull_limit

        # Constraints: Each cow breeds only once
        cows = _epds_with_target['cow'].unique().to_list()
        for cow_idx, cow in enumerate(cows):
            prob += lpSum(
                vars[i, j]
                for i in range(n)
                if _epds_with_target['cow'][i] == cow
                for j in range(len(bulls))
            ) <= 1

        # Solve the problem
        prob.solve()

        # Extract the results
        result = []
        for i in range(n):
            for j in range(len(bulls)):
                if vars[i, j].value() == 1:
                    result.append({
                        "cow": _epds_with_target['cow'][i], 
                        "bull": bulls[j]
                    })

        if not result:
            return None
            
        result__df = pl.DataFrame(result)
        
        # Count bulls
        bull_counts = result__df.group_by("bull").agg(
            pl.len().alias("count")
        ).sort("count", descending=True)
        
        return {
            "pairings": result__df,
            "bull_counts": bull_counts
        }
    except Exception as e:
        st.error(f"Optimization error: {e}")
        return None


#Option 3

@st.cache_data
def run_optimization(_epds_with_target):
    try:
        # Get unique cows and bulls
        cows = _epds_with_target['cow'].unique().to_list()
        bulls = _epds_with_target['bull'].unique().to_list()
        
        # Calculate the bull limit (1/5 of the unique cows)
        bull_limit = len(cows) // 5
        
        # Calculate means for relevant metrics
        mean_values = {
            'HB': _epds_with_target.select(pl.mean('HB')).item(),
            'GM': _epds_with_target.select(pl.mean('GM')).item(),
            'target': _epds_with_target.select(pl.mean('target')).item(),
            'ME': _epds_with_target.select(pl.mean('ME')).item(),
            'CED': _epds_with_target.select(pl.mean('CED')).item(),
            'Milk': _epds_with_target.select(pl.mean('Milk')).item(),
            'CEM': _epds_with_target.select(pl.mean('CEM')).item(),
            'Marb': _epds_with_target.select(pl.mean('Marb')).item(),
            'STAY': _epds_with_target.select(pl.mean('STAY')).item()
        }
        
        # Initialize the optimization problem
        prob = LpProblem("Breeding_Optimization", LpMaximize)
        
        # Create decision variables
        n = len(_epds_with_target)
        vars = {
            i: LpVariable(f"x_{i}", cat=LpBinary)
            for i in range(n)
        }
        
        # Calculate a score for each pairing that combines:
        # 1. Number of metrics above mean
        # 2. The maximum of HB or GM (whichever is higher)
        pairing_scores = []
        for i in range(n):
            row = _epds_with_target.row(i)
            
            # Count metrics where this pairing exceeds the mean
            above_mean_count = 0
            metrics = ['HB', 'GM', 'target', 'CED', 'Milk', 'CEM', 'Marb', 'STAY']
            for metric in metrics:
                metric_idx = _epds_with_target.columns.index(metric)
                metric_value = row[metric_idx]
                
                # For ME, lower is better so we check if it's below mean
                if metric == 'ME':
                    if row[_epds_with_target.columns.index('ME')] < mean_values['ME']:
                        above_mean_count += 1
                # For others, higher is better
                elif metric_value > mean_values[metric]:
                    above_mean_count += 1
            
            # Get HB and GM values
            hb_value = row[_epds_with_target.columns.index('HB')]
            gm_value = row[_epds_with_target.columns.index('GM')]
            
            # Calculate a combined score that prioritizes:
            # 1. Number of metrics above mean (weighted more heavily)
            # 2. The maximum of HB or GM
            max_hb_gm = max(hb_value, gm_value)
            
            # Store cow, bull, and score information
            pairing_scores.append({
                'index': i,
                'cow': row[_epds_with_target.columns.index('cow')],
                'bull': row[_epds_with_target.columns.index('bull')],
                'above_mean_count': above_mean_count,
                'max_hb_gm': max_hb_gm,
                'hb': hb_value,
                'gm': gm_value
            })
        
        # Objective function: Maximize a weighted combination of:
        # 1. The number of metrics above mean (weighted more heavily)
        # 2. The maximum of HB or GM for each selected pairing
        prob += lpSum(
            vars[i] * (5 * pairing_scores[i]['above_mean_count'] + pairing_scores[i]['max_hb_gm'])
            for i in range(n)
        )
        
        # Constraint: Each cow breeds only once
        for cow in cows:
            prob += lpSum(
                vars[i]
                for i in range(n)
                if pairing_scores[i]['cow'] == cow
            ) <= 1
        
        # Constraint: Each bull can breed with at most bull_limit cows
        for bull in bulls:
            prob += lpSum(
                vars[i]
                for i in range(n)
                if pairing_scores[i]['bull'] == bull
            ) <= bull_limit
        
        # Solve the problem
        prob.solve()
        
        # Extract the results
        result = []
        for i in range(n):
            if vars[i].value() == 1:  # If this pairing is selected
                result.append({
                    "cow": pairing_scores[i]['cow'],
                    "bull": pairing_scores[i]['bull'],
                    "above_mean_metrics": pairing_scores[i]['above_mean_count'],
                    "max_hb_gm": pairing_scores[i]['max_hb_gm'],
                    "hb": pairing_scores[i]['hb'],
                    "gm": pairing_scores[i]['gm']
                })
        
        if not result:
            return None
            
        result_df = pl.DataFrame(result)
        
        # Count bulls
        bull_counts = result_df.group_by("bull").agg(
            pl.len().alias("count")
        ).sort("count", descending=True)
        
        return {
            "pairings": result_df,
            "bull_counts": bull_counts
        }
    except Exception as e:
        st.error(f"Optimization error: {e}")
        return None


#Option 4
@st.cache_data
def run_optimization(_epds_with_target):
    try:
        # Get unique cows and bulls
        cows = _epds_with_target['cow'].unique().to_list()
        bulls = _epds_with_target['bull'].unique().to_list()
        
        # Calculate the bull limit (1/5 of the unique cows)
        bull_limit = len(cows) // 5
        
        # Calculate means for relevant metrics
        mean_values = {
            'HB': _epds_with_target.select(pl.mean('HB')).item(),
            'GM': _epds_with_target.select(pl.mean('GM')).item(),
            'target': _epds_with_target.select(pl.mean('target')).item(),
            'ME': _epds_with_target.select(pl.mean('ME')).item(),
            'CED': _epds_with_target.select(pl.mean('CED')).item(),
            'Milk': _epds_with_target.select(pl.mean('Milk')).item(),
            'CEM': _epds_with_target.select(pl.mean('CEM')).item(),
            'Marb': _epds_with_target.select(pl.mean('Marb')).item(),
            'STAY': _epds_with_target.select(pl.mean('STAY')).item()
        }
        
        # Calculate standard deviations for normalization
        std_values = {
            'HB': max(_epds_with_target.select(pl.std('HB')).item(), 0.0001),  # Avoid division by zero
            'GM': max(_epds_with_target.select(pl.std('GM')).item(), 0.0001),
            'ME': max(_epds_with_target.select(pl.std('ME')).item(), 0.0001),
            'CED': max(_epds_with_target.select(pl.std('CED')).item(), 0.0001),
            'Milk': max(_epds_with_target.select(pl.std('Milk')).item(), 0.0001),
            'CEM': max(_epds_with_target.select(pl.std('CEM')).item(), 0.0001),
            'Marb': max(_epds_with_target.select(pl.std('Marb')).item(), 0.0001),
            'STAY': max(_epds_with_target.select(pl.std('STAY')).item(), 0.0001),
        }
        
        # Initialize the optimization problem
        prob = LpProblem("Breeding_Optimization", LpMaximize)
        
        # Create decision variables
        n = len(_epds_with_target)
        vars = {
            i: LpVariable(f"x_{i}", cat=LpBinary)
            for i in range(n)
        }
        
        # Calculate a score for each pairing based on standardized distances from the mean
        pairing_scores = []
        metrics = ['HB', 'GM', 'CED', 'Milk', 'CEM', 'Marb', 'STAY', 'ME']
        
        for i in range(n):
            row = _epds_with_target.row(i)
            cow = row[_epds_with_target.columns.index('cow')]
            bull = row[_epds_with_target.columns.index('bull')]
            
            # Calculate standardized distance from mean for each metric
            metric_scores = {}
            total_distance = 0
            above_mean_count = 0
            
            for metric in metrics:
                metric_idx = _epds_with_target.columns.index(metric)
                metric_value = row[metric_idx]
                
                # For ME, lower is better
                if metric == 'ME':
                    # Negative z-score since lower is better
                    z_score = (mean_values[metric] - metric_value) / std_values[metric]
                    is_better = metric_value < mean_values[metric]
                else:
                    # Positive z-score since higher is better
                    z_score = (metric_value - mean_values[metric]) / std_values[metric]
                    is_better = metric_value > mean_values[metric]
                
                # Only count positive contributions (better than mean)
                if is_better:
                    above_mean_count += 1
                    total_distance += max(0, z_score)  # Only use positive distance
                
                metric_scores[metric] = {
                    'value': metric_value,
                    'z_score': z_score,
                    'is_better': is_better
                }
            
            # Store all the information for this pairing
            pairing_scores.append({
                'index': i,
                'cow': cow,
                'bull': bull,
                'above_mean_count': above_mean_count,
                'total_distance': total_distance,
                'metrics': metric_scores,
                'hb': row[_epds_with_target.columns.index('HB')],
                'gm': row[_epds_with_target.columns.index('GM')]
            })
        
        # Objective function: Maximize the combined score of:
        # 1. Number of metrics above mean
        # 2. Total standardized distance above the mean across all metrics
        prob += lpSum(
            vars[i] * (3 * pairing_scores[i]['above_mean_count'] + pairing_scores[i]['total_distance'])
            for i in range(n)
        )
        
        # Constraint: Each cow breeds only once
        for cow in cows:
            prob += lpSum(
                vars[i]
                for i in range(n)
                if pairing_scores[i]['cow'] == cow
            ) <= 1
        
        # Constraint: Each bull can breed with at most bull_limit cows
        for bull in bulls:
            prob += lpSum(
                vars[i]
                for i in range(n)
                if pairing_scores[i]['bull'] == bull
            ) <= bull_limit
        
        # Solve the problem
        prob.solve()
        
        # Extract the results
        result = []
        for i in range(n):
            if vars[i].value() == 1:  # If this pairing is selected
                result.append({
                    "cow": pairing_scores[i]['cow'],
                    "bull": pairing_scores[i]['bull'],
                    "above_mean_count": pairing_scores[i]['above_mean_count'],
                    "total_distance": round(pairing_scores[i]['total_distance'], 2),
                    "hb": pairing_scores[i]['hb'],
                    "gm": pairing_scores[i]['gm']
                })
        
        if not result:
            return None
            
        result_df = pl.DataFrame(result)
        
        # Count bulls
        bull_counts = result_df.group_by("bull").agg(
            pl.len().alias("count")
        ).sort("count", descending=True)
        
        return {
            "pairings": result_df,
            "bull_counts": bull_counts
        }
    except Exception as e:
        st.error(f"Optimization error: {e}")
        return None

```


```{python}
@st.cache_data
def run_optimization(_epds_with_target, target_values=None):
    """
    Optimize breeding pairs based on target values for various traits.
    ENSURES ALL COWS GET PAIRED with no exclusions.
    
    Parameters:
    _epds_with_target - DataFrame with cow/bull pairs and their traits
    target_values - Dictionary with target values for each trait
    """
    try:
        # Default target values if not provided
        if target_values is None:
            target_values = {
                'CED': 14, 'BW': -3, 'WW': 65, 'YW': 100, 'ADG': 0.28,
                'DMI': 0.6, 'Milk': 29, 'ME': -2, 'HPG': 12, 'CEM': 8,
                'STAY': 18, 'Marb': 0.5, 'YG': 0.03, 'CW': 29, 'REA': 0.17,
                'FAT': 0, 'HB': 70, 'GM': 46
            }
        
        # Define metrics where lower values are better
        lower_is_better = ['DMI', 'BW', 'ME', 'YG', 'FAT']
        
        # Get unique cows and bulls
        cows = _epds_with_target['cow'].unique().to_list()
        bulls = _epds_with_target['bull'].unique().to_list()
        
        # Calculate the original bull limit
        original_bull_limit = max(1, len(cows) // 5)
        
        # Calculate minimum required bull limit to ensure all cows get paired
        required_bull_limit = (len(cows) + len(bulls) - 1) // len(bulls)
        
        # Use the higher of the two to ensure all cows get paired
        bull_limit = max(original_bull_limit, required_bull_limit)
        
        # Identify all metrics to use in optimization
        all_metrics = ['CED', 'BW', 'WW', 'YW', 'ADG', 'DMI', 'Milk', 'ME', 'HPG', 
                      'CEM', 'STAY', 'Marb', 'YG', 'CW', 'REA', 'FAT', 'HB', 'GM']
        
        # Filter to only metrics present in the data
        available_metrics = [m for m in all_metrics if m in _epds_with_target.columns]
        
        # Calculate standard deviations for normalization
        std_values = {}
        for metric in available_metrics:
            std_values[metric] = max(_epds_with_target.select(pl.std(metric)).item(), 0.0001)
        
        # Calculate a score for each pairing based on closeness to target values
        pairing_scores = []
        
        for i in range(len(_epds_with_target)):
            row = _epds_with_target.row(i)
            cow = row[_epds_with_target.columns.index('cow')]
            bull = row[_epds_with_target.columns.index('bull')]
            
            # Calculate standardized distance from target for each metric
            metric_scores = {}
            total_score = 0
            better_than_target_count = 0
            
            for metric in available_metrics:
                if metric in _epds_with_target.columns:
                    metric_idx = _epds_with_target.columns.index(metric)
                    metric_value = row[metric_idx]
                    target = target_values.get(metric, 0)
                    
                    # Calculate z-score differently based on whether lower or higher is better
                    if metric in lower_is_better:
                        # For metrics where lower is better, a negative z-score is good
                        z_score = (target - metric_value) / std_values[metric]
                        is_better = metric_value <= target
                    else:
                        # For metrics where higher is better, a positive z-score is good
                        z_score = (metric_value - target) / std_values[metric]
                        is_better = metric_value >= target
                    
                    # Only count positive contributions (better than target)
                    if is_better:
                        better_than_target_count += 1
                        total_score += max(0, z_score)  # Only use positive score
                    
                    metric_scores[metric] = {
                        'value': metric_value,
                        'target': target,
                        'z_score': z_score,
                        'is_better': is_better
                    }
            
            # Store all the information for this pairing
            pairing_scores.append({
                'index': i,
                'cow': cow,
                'bull': bull,
                'better_than_target_count': better_than_target_count,
                'total_score': total_score,
                'metrics': metric_scores
            })
        
        # Function to solve the optimization
        def solve_optimization(excluded_pairings=None):
            from pulp import LpProblem, LpMaximize, LpVariable, LpBinary, lpSum
            
            # Initialize the optimization problem
            prob = LpProblem("Breeding_Optimization", LpMaximize)
            
            # Create decision variables
            n = len(_epds_with_target)
            vars = {
                i: LpVariable(f"x_{i}", cat=LpBinary)
                for i in range(n)
            }
            
            # Objective function: Maximize the combined score
            prob += lpSum(
                vars[i] * (3 * pairing_scores[i]['better_than_target_count'] + pairing_scores[i]['total_score'])
                for i in range(n)
            )
            
            # CRITICAL CONSTRAINT: Each cow breeds EXACTLY once - this ensures ALL cows get paired
            for cow in cows:
                prob += lpSum(
                    vars[i]
                    for i in range(n)
                    if pairing_scores[i]['cow'] == cow
                ) == 1  # EXACTLY one pairing per cow
            
            # Constraint: Each bull can breed with at most bull_limit cows
            for bull in bulls:
                prob += lpSum(
                    vars[i]
                    for i in range(n)
                    if pairing_scores[i]['bull'] == bull
                ) <= bull_limit
            
            # Add exclusion constraints if any
            if excluded_pairings:
                # Force at least one pairing to be different
                prob += lpSum(
                    vars[i] for i in excluded_pairings
                ) <= len(excluded_pairings) - 1
            
            # Solve the problem
            status = prob.solve()
            
            # If the problem couldn't be solved with the exact constraint,
            # we need to relax the bull limit
            if status != 1:
                # Calculate a higher bull limit that will definitely work
                new_bull_limit = (len(cows) + len(bulls) - 1) // len(bulls)
                st.warning(f"Could not find a solution with bull limit {bull_limit}. " 
                           f"Increasing to {new_bull_limit} to ensure all cows get paired.")
                
                # Update the constraint
                for bull in bulls:
                    prob.constraints[f"Bull_{bull}"].changeRHS(new_bull_limit)
                
                # Try solving again
                status = prob.solve()
                
                # If still failing, create a last-resort solution by assigning cows
                # to bulls without optimization
                if status != 1:
                    st.error("Could not solve optimization problem. Using fallback method.")
                    # Create a simple assignment (each cow to its best bull)
                    result = []
                    selected_indices = []
                    
                    # Group by cow and find best bull for each
                    cow_bull_scores = {}
                    for i in range(n):
                        cow = pairing_scores[i]['cow']
                        score = pairing_scores[i]['better_than_target_count'] + pairing_scores[i]['total_score']
                        
                        if cow not in cow_bull_scores or score > cow_bull_scores[cow]['score']:
                            cow_bull_scores[cow] = {
                                'index': i,
                                'score': score
                            }
                    
                    # Create result from best bull for each cow
                    for cow, data in cow_bull_scores.items():
                        i = data['index']
                        selected_pair = {
                            "cow": pairing_scores[i]['cow'],
                            "bull": pairing_scores[i]['bull'],
                            "better_than_target_count": pairing_scores[i]['better_than_target_count'],
                            "total_score": round(pairing_scores[i]['total_score'], 2)
                        }
                        
                        # Include individual metric values
                        for metric in available_metrics:
                            if metric in pairing_scores[i]['metrics']:
                                selected_pair[metric] = pairing_scores[i]['metrics'][metric]['value']
                        
                        result.append(selected_pair)
                        selected_indices.append(i)
                    
                    return result, selected_indices
            
            # Extract the results
            result = []
            selected_indices = []
            for i in range(n):
                if vars[i].value() == 1:  # If this pairing is selected
                    selected_pair = {
                        "cow": pairing_scores[i]['cow'],
                        "bull": pairing_scores[i]['bull'],
                        "better_than_target_count": pairing_scores[i]['better_than_target_count'],
                        "total_score": round(pairing_scores[i]['total_score'], 2)
                    }
                    
                    # Include individual metric values in the result
                    for metric in available_metrics:
                        if metric in pairing_scores[i]['metrics']:
                            selected_pair[metric] = pairing_scores[i]['metrics'][metric]['value']
                    
                    result.append(selected_pair)
                    selected_indices.append(i)
            
            # Verify that all cows are paired
            paired_cows = set(item["cow"] for item in result)
            if len(paired_cows) < len(cows):
                st.warning(f"Only {len(paired_cows)} cows out of {len(cows)} were paired. " 
                           "Using fallback method to ensure all cows get paired.")
                
                # Add the remaining cows with their best available bull
                for cow in cows:
                    if cow not in paired_cows:
                        # Find the best score for this cow
                        best_score = -float('inf')
                        best_idx = -1
                        
                        for i in range(n):
                            if pairing_scores[i]['cow'] == cow and i not in selected_indices:
                                score = pairing_scores[i]['better_than_target_count'] + pairing_scores[i]['total_score']
                                if score > best_score:
                                    best_score = score
                                    best_idx = i
                        
                        if best_idx >= 0:
                            i = best_idx
                            selected_pair = {
                                "cow": pairing_scores[i]['cow'],
                                "bull": pairing_scores[i]['bull'],
                                "better_than_target_count": pairing_scores[i]['better_than_target_count'],
                                "total_score": round(pairing_scores[i]['total_score'], 2)
                            }
                            
                            # Include individual metric values
                            for metric in available_metrics:
                                if metric in pairing_scores[i]['metrics']:
                                    selected_pair[metric] = pairing_scores[i]['metrics'][metric]['value']
                            
                            result.append(selected_pair)
                            selected_indices.append(i)
            
            return result, selected_indices
        
        # Generate the initial solution
        primary_solution, primary_indices = solve_optimization()
        
        # Generate a secondary solution by excluding the primary solution
        secondary_solution, secondary_indices = solve_optimization(primary_indices)
        
        # Convert solutions to DataFrames
        primary_pairings = pl.DataFrame(primary_solution)
        
        # Count bulls in primary solution
        primary_bull_counts = primary_pairings.group_by("bull").agg(
            pl.count().alias("count")
        ).sort("count", descending=True)
        
        # Do the same for secondary solution
        if secondary_solution:
            secondary_pairings = pl.DataFrame(secondary_solution)
            secondary_bull_counts = secondary_pairings.group_by("bull").agg(
                pl.count().alias("count")
            ).sort("count", descending=True)
        else:
            secondary_pairings = None
            secondary_bull_counts = None
        
        # Verify that all cows are paired in the primary solution
        paired_cows = set(primary_pairings['cow'].to_list())
        if len(paired_cows) != len(cows):
            st.error(f"ERROR: Only {len(paired_cows)} cows out of {len(cows)} were paired! Please contact support.")
        
        return {
            "primary_pairings": primary_pairings,
            "primary_bull_counts": primary_bull_counts,
            "secondary_pairings": secondary_pairings,
            "secondary_bull_counts": secondary_bull_counts,
            "selected_indices": primary_indices,
            "pairing_scores": pairing_scores,
            "available_metrics": available_metrics,
            "target_values": target_values,
            "total_cows": len(cows),
            "total_bulls": len(bulls),
            "bull_limit": bull_limit
        }
        
    except Exception as e:
        import traceback
        st.error(f"Optimization error: {e}")
        st.error(traceback.format_exc())
        return None
```